package kiama

/**
 * Fucking everything in this object will fail if you didn't call initTree(diagram)
 */
object SemanticAnalysis {

	import org.kiama.attribution.Attribution._
	import org.kiama.util.Messaging._

  /**
   * inherit the root diagram to every node
   */
	val diagram : SeqBase => SeqDiagram =
		attr {
			case d : SeqDiagram => d
			case b : SeqBase => diagram(b.parent[SeqBase])
		}

  /**
   * get every object a reference to the specified class
   */
	val clazz: SeqObject => Option[SeqClass] =
		attr {
			case o @ SeqObject(_, c) => diagram(o).classes.find(_.name == c)
		}

	val srcObj: SeqInteraction => Option[SeqObject] =
		attr {
			case i @ SeqInteraction(s, _, _) => diagram(i).objects.find(_.name == s)
		}

	val targetObj: SeqInteraction => Option[SeqObject] =
		attr {
			case i @ SeqInteraction(_, t, _) => diagram(i).objects.find(_.name == t)
		}

	val methodObj: SeqInteraction => Option[SeqMethod] =
		attr {
			case i @ SeqInteraction(_, _, m) =>
				targetObj(i) flatMap {clazz(_) flatMap {_.methods.find(_.name == m)} }
		}

	//test if the given SeqBase is valid
	def isValid(d: SeqDiagram) : Boolean = {
		d.classes.map(isValid).reduce(_&&_) &&
		d.objects.map(isValid).reduce(_&&_) &&
		d.interactions.map(isValid).reduce(_&&_)
	}

	def isValid(o: SeqObject) =
		clazz(o).isDefined && diagram(c).objects.forall(x => (x ne o) || x.name != o.name)

	def isValid(c: SeqClass) = diagram(c).classes.forall(x => (x ne c) || x.name != c.name)

	def isValid(i: SeqInteraction) =
		srcObj(i).isDefined && targetObj(i).isDefined && methodObj(i).isDefined

	// search for semantic errors and submit them to the message module
	def check(d: SeqDiagram) {
		for((n,cs) <- d.classes.groupBy(_.name); if(cs.size > 1)) {
		  message(cs.head, "There are two or more classes with the same name: " + n)
		}
		for (o <- d.objects; if (!clazz(o).isDefined)) {
			message(o, "There is no class with name " + o.seqClass)
		}
		for((n,os) <- d.objects.groupBy(_.name); if(os.size > 1)) {
		  message(os.head, "There are two or more objects with the same name: " + os.head.name)
		}
		for (i <- d.interactions) {
			if (!srcObj(i).isDefined)
				message(i, "The source object " + i.source + " does not exist1")
			if (!targetObj(i).isDefined)
				message(i, "The target object " + i.target + " does not exist!")
			else if (!methodObj(i).isDefined)
				message(i, "The method " + i.method + " does not exist in class " + targetObj(i).get.seqClass)
		}
	}


//	def checkDiagram(d: SeqDiagram): Boolean = {
//		val getClass: SeqObject => Option[SeqClass] =
//			attr {
//				case o@SeqObject(_, c) => d.classes.find(_.name == c)
//			}
//
//		val getSourceObject: SeqInteraction => Option[SeqObject] =
//			attr {
//				case i @ SeqInteraction(s, _, _) => d.objects.find(_.name == s)
//			}
//
//		val getTargetObject: SeqInteraction => Option[SeqObject] =
//			attr {
//				case i @ SeqInteraction(_, t, _) => d.objects.find(_.name == t)
//			}
//
//		def check(b: SeqBase): Boolean = {
//			b match {
//				case SeqDiagram(_, cs,os, is) =>
//					var ok = true
//					for (c <- cs) ok &&= check(c)
//					for (o <- os) ok &&= check(o)
//					for (i <- is) ok &&= check(i)
//					ok
//				case c : SeqClass =>
//					true
//				case m : SeqMethod =>
//					true
//				case o: SeqObject =>
//					getClass(o).isDefined
//				case i @ SeqInteraction(_,_,m) =>
//					getSourceObject(i).isDefined &&
//						getTargetObject(i).isDefined &&
//						getClass(getTargetObject(i).get).get.methods.find(_.name == m).isDefined
//			}
//		}
//		check(d)
//	}
}
